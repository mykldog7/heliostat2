package main

import (
	"bytes"
	"context"
	"fmt"
	"log"
	"strings"

	"go.bug.st/serial"
)

type GrblArduino struct {
	fromGrbl chan []byte
	toGrbl   chan []byte
}

func NewGrblArduino(ctx context.Context) (*GrblArduino, error) {
	mode := &serial.Mode{
		BaudRate: 115200, //adjust baud here, or other serial connection settings
	}
	//Connect to each port returning the one that is the grbl arduino
	port, err := getGrblPort(mode)
	if err != nil {
		return nil, err
	}
	log.Printf("Found Grbl on %v\n", port)
	grbl := GrblArduino{
		toGrbl:   make(chan []byte),
		fromGrbl: make(chan []byte),
	}
	//Control loop, writes to fromGrbl, sends from toGrbl, terminates on ctx.Done
	go func() {
		log.Printf("Connecting to Grbl on port: %v\n", port)
		p, _ := serial.Open(port, mode)
		//reader returns a 'msg' at a time from grbl, it breaks on '\r\nok\r\n' patterns
		reader := grbl.ReadChan(p, ctx)
		p.Write([]byte("$I\n")) //request boards grbl version, provides the first 'ok' response.
		for {
			select {
			case <-ctx.Done():
				p.Close()
				return
			case msg := <-grbl.toGrbl:
				_, err := p.Write(msg)
				if err != nil {
					log.Fatal(err)
				}
			case msg := <-reader:
				grbl.fromGrbl <- msg
			}
		}
	}()
	return &grbl, nil
}

// ReadChan returns a chan []byte that can be used to read from the Arduino
func (g *GrblArduino) ReadChan(p serial.Port, ctx context.Context) chan []byte {
	buff := make([]byte, 1)
	c := make(chan []byte)

	//read bytes into 'c' as long as the context is open
	go func() {
		for {
			select {
			case <-ctx.Done():
				close(c)
				return
			default:
				msg := []byte{}
				//build up a buffer reading a single char at a time from the serial port, when the \r\nok\r\n pattern is found then the message is relayed upstream
				for {
					_, err := p.Read(buff)
					if err != nil {
						log.Fatal(err)
					}
					msg = append(msg, buff...)
					//if its a 'GCode Parse State Block' return by itself, generated by sending '$G'
					if len(msg) > 6 {
						//we are assuming that 'grbl' sends an <newline>ok<newline> pattern to close every response
						if bytes.Equal(msg[len(msg)-6:], []byte("\r\nok\r\n")) {
							break
						}
					}
				}
				c <- msg[:len(msg)-6]
			}
		}
	}()

	//returning the channel so we can read it
	return c
}

func getGrblPort(mode *serial.Mode) (string, error) {
	ports, err := serial.GetPortsList()
	if err != nil {
		log.Fatal(err)
		return "", err
	}
	if len(ports) == 0 {
		return "", fmt.Errorf("no serial ports available, is grbl(arduino) connnected?")
	}
	for _, port := range ports {
		log.Printf("Checking port: %v to see if it is \"Grbl\"...\n", port)
		p, err := serial.Open(port, mode)
		if err != nil {
			return "", err
		}
		buff := make([]byte, 7)
		_, err = p.Read(buff)
		if err != nil {
			return "", err
		}
		if strings.TrimSpace(string(buff)) == "Grbl" {
			return port, nil //happy path... returns the port that can be used to connect
		}
		p.Close()
	}
	return "", fmt.Errorf("no serial ports with Grbl detected")
}
